## 056. 전화번호 목록

## 풀이

문자열로 정렬한 후, i번째가 i+1번째의 시작인지 아닌지를 비교하여 시작인 게 있으면 false를 끝까지 없으면 true를 리턴한다.

## 생각

N개 번호를 서로 비교하기 위해 O(N^2)이 필요하다고 생각했고, 짧은 것을 기준으로 비교하면 반으로 줄것이라 생각하였다.
그래서 처음에는 정렬을 하고 이중 for문을 돌려 비교를 진행하였다.
결과는 무난했고, 통과할 수 있었다.
그리고 다른 사람의 풀이를 보게 되었다.

가장 위에 올라와 있는 풀이는 for문을 한 번만 돌았고, i번째와 i+1번째를 비교하였다.
처음에 난 이해할 수 없었다.
바로 붙어 있는 번호들만 비교하여 가능할까?

그런데 생각을 해보니 문자열 상태의 번호를 정렬하게 되면 앞에서부터 비교를 하게 되어 바로 옆에 있는 번호가 아니면 앞이 겹칠 일이 없었다.
그렇기 때문에 다른 번호를 비교하지 않고, 옆의 번호만 비교하면 되는 것이었다.
어차피 시작하는게 하나라도 있으면 끝나는 문제이기에.

이번 문제를 통해서도 또 하나 배웠다.

## 다른 사람 풀이
startswith 함수도 그렇고 한 번의 for문으로 해결할 수 있다는 것을 알려준 코드.
```
def solution(phoneBook):
    phoneBook = sorted(phoneBook)

    for p1, p2 in zip(phoneBook, phoneBook[1:]):
        if p2.startswith(p1):
            return False
    return True
```
