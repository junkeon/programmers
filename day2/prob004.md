## 004. 체육복

## 풀이

먼저 lost와 reserve에서 겹치는 번호를 빼주고, lost의 번호 -1나 +1의 번호가 reserve에 있으면 빼준 후 전체 학생수에서 lost의 원소 수를 빼준다

## 생각

빌려줄 수 있는 경우가 여러가지 있다고 생각했고, 이 경우에 따라 결과가 달라져 각 경우를 비교하고자 생각하였다.
이 경우를 모두 고려하는데에 어려움이 있어 복잡한 문제라고 생각했으나, 문제 유형이 탐욕법이라고 되어 있어 탐욕법으로 접근하려고 하였다.
(아직 경험이 부족하여 문제만 보고 유형을 파악하는 데에는 어려움이 있다.)

가장 먼저 생각해준 것은 여벌의 체육복을 가져온 학생이 잃어버리는 경우였다.
이러한 경우 남은 체육복이 하나이기 때문에 빌려줄 수 없어 바로 여벌이 없는 경우로 볼 수 있기 때문이다.

그 다음에는 탐욕법으로 접근하기 위해 모든 경우를 고려하기 보다는 문제 조건을 바로 적용하였다.
그래서 도난 당한 학생의 앞뒤 학생이 여벌의 체육복을 가져온 경우 각각 lost와 reserve에서 빼는 것으로 구현했다.
이 부분에서 리스트에 대한 for문은 돌면서 원소를 제거해야 하는데, 도중에 원소가 제거되면 제거된 원소의 다음이 아닌 그 다음 원소로 접근한다.
그래서 for문을 돌때, for문의 대상을 deep copy로 하여 돌게 하였다.

그리고 두번째 이슈는 리스트에서 원소를 제거하는 함수였다.
처음에 성공한 코드에서는 del과 인덱스로 리스트에서 원소를 제거하는 방식을 사용했다.
그런데 다른 사람 풀이를 통해 remove라는 함수를 이용하면 인덱스를 사용할 필요가 없었다.

## 다른 사람 풀이

다른 사람 풀이에서는 lost와 reserve에서 중복되는 원소를 나의 풀이와는 다르게 comprehension을 이용하여 처리해주었다.
그리고 이중 for문을 이용하여 앞뒤 번호를 고려하고, remove 함수로 원소를 제거하였다. (이 부분을 코드에 반영함)

```
def solution(n, lost, reserve):
    _reserve = [r for r in reserve if r not in lost]
    _lost = [l for l in lost if l not in reserve]
    for r in _reserve:
        f = r - 1
        b = r + 1
        if f in _lost:
            _lost.remove(f)
        elif b in _lost:
            _lost.remove(b)
    return n - len(_lost)
```
