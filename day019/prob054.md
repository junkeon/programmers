## 054. 가장 큰 수

## 풀이

주어진 수를 문자열로 변환한 후 3번 반복되게 한 문자열을 기준으로 역정렬하여 이어 붙여준 후 앞의 0을 제거하기 위해 int로 변환하였다가 문자열로 변환하여 리턴한다.

## 생각

이 문제는 이전에 마주했다가 풀지 못했던 기억이 난다.

예전에 풀었을 때는 combination을 사용하여 모든 경우의 수를 다 비교하다가 테스트 케이스에서 시간초과가 났다.

이번에는 문자열을 정렬한 후 크기 비교를 통해 풀고자 하였다.
이런 접근법을 택한 이유는 다음과 같다.

이 문제에서 큰 수를 만들기 위해 수를 정할 때에는 크기의 비교가 아닌 각 수의 앞자리수부터 비교를 해야 한다.
10000과 9를 비교할 때 각각 수의 앞자리수는 1과 9이므로 두 수가 이어 붙여졌을 때 10000보다 9가 더 크게 만들 수 있기 때문이다.
그렇게 때문에 정수로서 비교하는 것은 의미가 없고, 문자열로 변환한 후 비교를 해야 앞자리수부터 비교가 된다.
그러나 이렇게만 했을 때 다음과 같은 문제가 있었다.

3, 30, 34를 비교했을 때, 문자열로 변환 후 비교하면, 34 > 30 > 3이 된다. 그래서 이 세 수로만 위의 방법으로 이어붙이면, 34303이 된다.
하지만 실제로 해보면 가장 크게 되는 것은 34330(34 - 3 - 30)이 되어야 한다. 즉 3이 30보다 커야 한다.
이렇게 해줄 수 있는 방법을 고민한다가 반복한 후 비교하는 법을 생각하게 되었다.

3과 30을 반복하게 되면, 3은 33이 되고, 30은 3030이 된다. 이렇게되면 첫번째 자리수는 3으로 동일하지만, 그 다음 자리수는 3과 0을 비교하게 되므로 3이 30보다 먼저 선택되게 된다.
그러면 반복할 때 몇번 반복하는지를 결정해야 한다.
반복하는 횟수가 너무 적으면 긴 수(자리수가 많은)에 대해서는 비교가 되지 않고, 너무 많으면 시간이 늘기 때문이다.

이 문제에 대한 답은 제한 사항에서 찾았다.
제한 사항에 따르면 numbers의 원소는 0부터 1000이하이라고 명시했기 때문에 3번이면 충분했다.

마지막으로 0으로 시작하는 수를 고려해주어야 했다.
위의 방법들로 답안을 작성하고 단순히 ''.join을 이용하여 문자열로 변환하였을 때, 마지막 테스트 케이스에서 실패가 났다.
왜 그럴까를 생각하다가, 제한 사항에서 numbers의 범위가 0부터 시작한다는 것을 보고 깨달았다.
만약 모든 numbers의 원소가 0이 되게 되면, 결과값은 0이 되게 되는데, 나의 풀이에 따르면 0이 아니라 0이 여러개 붙여진 형태가 되었다.
따라서 이런 경우를 방지하기 위해 int로 변환했다가 문자열로 변환하여 0으로 만들어주어야 했다.


## 다른 사람 풀이
나의 풀이에 많은 도움을 준 코드
```
def solution(numbers):
    numbers = list(map(str, numbers))
    numbers.sort(key=lambda x: x*3, reverse=True)
    return str(int(''.join(numbers)))
```
