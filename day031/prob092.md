## 092. 네트워크

## 풀이

깊이 우선 탐색을 이용하여 한 컴퓨터에 연결된 모든 컴퓨터들을 search에서 찾아 제거하고 남은 컴퓨터에 대해 같은 과정을 반복하여 모든 컴퓨터를 조사한다.

## 생각

answer에는 0으로 초기화하여 네트워크 개수를 저장하고, queue에는 현재 조사할 네트워크에 연결된 컴퓨터들의 정보를 담는다. search에는 조사가 되어야 할 컴퓨터의 인덱스를 담는다.

깊이 탐색을 위해 search에 컴퓨터가 모두 없어질때까지 다음의 과정을 반복하게 된다.

먼저 네트워크 수를 하나 늘리고 search에서 조사가 되어야 할 컴퓨터 하나를 꺼내온 후 queue에 컴퓨터 인덱스와 네트워크 연결 정보를 담는다.

그런 후 queue가 다 빌 때까지 네트워크에 포함된 컴퓨터 정보를 꺼내어 네트워크 연결 정보를 기반으로 현재 네트워크에 포함된 컴퓨터 정보를 queue에 담는 동시에 search에서 인덱스를 제거해준다.

이 과정을 반복하면 search에 포함된 컴퓨터 인덱스 수는 줄어가고 결국 네트워크 수만큼 queue가 쌓였다, 비었다를 반복하면서 네트워크 수를 알 수 있게 된다.

## 다른 사람 풀이
아주 간결한 풀이이다.
먼저 temp에 모든 컴퓨터들의 인덱스를 담고, computers에 담긴 모든 정보를 순회하면서 연결된 컴퓨터들은 computers에서 같은 값이 되도록 바꿔준다.
그러면 결국 temp에 같은 네트워크에 있는 모든 컴퓨터들은 같은 값을 갖게 되어 중복 제거된 값의 수를 세어주면 네트워크의 수와 같아진다.

하지만 O(n^3)이 되어 시간은 더 걸리겠지만 매우 창의적이고 간결한 풀이라고 생각한다.
```
def solution(n, computers):
    temp = []
    for i in range(n):
        temp.append(i)
    for i in range(n):
        for j in range(n):
            if computers[i][j]:
                for k in range(n):
                    if temp[k] == temp[i]:
                        temp[k] = temp[j]
    return len(set(temp))
```
