## 050. 조이스틱

## 풀이

현재 위치에서 좌우로 탐색을 시작하여 가장 적은 위치로 갈 수 있는 곳을 탐색한 후 이동한다.

## 생각

이 문제는 이전에 시도했던 문제이고, 끝내 풀지 못했다.
그리고 다시 이 문제를 풀어야 했을때 솔직히 많이 걱정되었다.

몇번의 시도 끝에 한 아이디어를 생각해냈다.
그 아이디어는 어차피 같은 곳을 지나칠 일이 없으니 한쪽 방향으로만 이동하는 방법이었다.
여기서는 좌에서 우로만 혹은 우에서 좌로만 이동하는 경우를 비교하고자 하였다.

테스트 케이스는 별탈없이 통과하였고, 채점에서도 마지막 문제를 제외한 모든 문제를 통과했기에 무리없이 통과할 것이라고 생각했다.
그리고 그것은 나의 착각이었다.

AZAAAAAAZ와 같은 경우, 좌에서 우로 이동하여 두번째 Z를 수정하고 다시 우에서 좌로 이동하여 마지막 Z를 수정하는 것이 더 적은 이동이 된다.
그리고 이것을 가능하게 하기 위해서는 내 풀이가 완전히 달라져야 했다.

결국 검색 끝에 SSTF(Shortest Seek Time First)라는 스케쥴링 기법이 있는데, 이것을 이용하면 되는 것을 알아내었따.
SSTF는 디스크 스케줄링 기법 중 하나로 현재 헤드에서 가장 가까운 트랙의 요청을 먼저 처리하는 방법이다.
그렇기 때문에 seek time을 최소화할 수 있다는 장점이 있다.
이 문제에 적용하면 가장 적은 이동으로 수정을 할 수 있기 때문에 SSTF를 이용하여 풀기로 했다.

그래서 현재 위치를 기준으로 매 틱마다 좌와 우로 한칸씩 이동하면서 A가 아니어서 수정이 필요한 곳의 위치를 찾고, 수정하는 횟수를 더한 후 모든 곳이 수정을 필요로 하지 않을 때까지 반복하는 방식을 구현했다.

## 다른 사람 풀이
나의 풀이와 같은 아이디어지만, 더 간결하게 한 풀이가 있어서 가져왔다.
```
def solution(name):
    m = [ min(ord(c) - 65, 91-ord(c)) for c in name]       

    answer = 0
    where = 0

    while True:    
        answer += m[where]
        m[where] = 0

        if sum(m) == 0:
            break

        left, right = (1,1)

        while m[where - left] <= 0:
            left += 1
        while m[where + right] <= 0:
            right += 1

        answer += left if left < right else right
        where += -left if left < right else right

    return answer
```
