## 043. 주식 가격

## 풀이

스택을 이용하여 주가가 낮은 것들을 보관하고, 주식 가격이 떨어지는 것을 스택의 마지막부터 비교하여 떨어지는 시점을 기록한다.

## 생각

문제 유형에는 스택/큐라고 되어 있었다.
스택과 큐를 이용하여 푸는 문제인 것 같다.

처음 문제를 시도하였을 때는 시간초과로 성공하지 못했다.
한참을 고민하다가 다른 사람들의 풀이로 도움을 받는 방법을 택했다.

파이썬을 이용한 풀이는 크게 두가지 방식으로 나눌 수 있었다.
첫번째는 이중 for문을 돌면서 비교하는 방식, 두번째는 스택을 이용하는 방식.

도움을 얻은 입장에서 두 방식 모두를 설명하고자 한다.

첫번째는 이중 for문을 돌면서 비교하는 방식이다.
엄밀하게 말해서 이 방식은 스택을 사용하지 않는 방식이라 구분하는 것이 맞을 듯 싶다.
어차피 스택도 두번의 loop를 도는 건 마찬가지니까.
이 방식에서는 모든 원소에 대해, 그 이후로 그 원소보다 작은 원소가 나올 때까지 for문을 돌고 시간 차이를 기록하는 것이다.
매우 직관적인 방식이다.

두번째 방식은 스택을 이용하는 방식이다.
내가 생각하기 이 방식과 이전 방식에 가장 큰 차이점은 현재 원소가 언제 떨어지는지 구분한 것이 사전인가, 사후인가에 있다고 본다.
첫번째 방식의 경우 현재 원소를 이후 미래의 모든 원소를 비교하고 언제 떨어질지를 기록한다.
반면에 두번쨰 방식은 일단 스택에 저장해두고 다음 원소들을 보면서 스택에 있는 원소와 비교하여 스택에 있는 원소보다 더 작은 주가가 있으면, 그때 그 스택에 있는 원소가 언제 떨어지는지 기록되는 식이다.
따라서 첫번째 방식은 계속해서 미래를 비교하여야 하기 떄문에 중복으로 검사되는 데에 반해 두번쨰 방식은 한번에 이동하면서 스택과만 비교하기에 효율적인 것이다.

이러한 비교하는 문제는 앞으로 스택을 이용할 수 있을 거 같다.

그리고 이 문제를 풀면서 다음의 몇가지 테크닉을 얻은 것이 있다.

첫번째는 for문을 이용하여 시간을 절약하는 방식이다.
처음에 스택을 이용하지 않는 방식으로 풀면서 분명히 알고리즘은 같은데 시간초과가 난 적이 있다.
이때 내가 사용한 코드는 for문에서 인덱스를 받는 것이 enumerate로 인덱스와 원소를 받는 방식을 이용했다.
enumerate를 사용했을 때 나던 시간초과는 인덱스만 받는 방식으로 바꾸니 시간 초과가 나지 않았다.
당연히 원소를 받는 for문에서 list는 O(1)의 접근 시간을 가지기 때문에 차이가 없을 것이라고 생각했는데, 시간 차이가 많이 나는 듯 했다.

두번째는 answer의 저장 방식이다.
나는 처음에 이전처럼 answer를 빈 list로 하고 for문을 돌면서 append를 하는 식으로 기록하는 코드를 짰다.
그런데 어차피 answer의 길이는 정해져있고, default가 있는 상황에서는 append보다는 미리 초기화한 코드가 더 편리함을 알게 되었다.
미리 초기화를 하면 접근하기도 편하고, default 값을 굳이 조건문을 걸어가면서까지 넣을 필요가 없어 코드도 더 간결해졌다.

## 다른 사람 풀이
내 현재 풀이에 기본이 되는 코드.
이 코드를 보면서 많은 공부를 했다.

```
def solution(prices):
    stack = []
    answer = [0] * len(prices)
    for i in range(len(prices)):
        if stack != []:
            while stack != [] and stack[-1][1] > prices[i]:
                past, _ = stack.pop()
                answer[past] = i - past
        stack.append([i, prices[i]])
    for i, s in stack:
        answer[i] = len(prices) - 1 - i
    return answer
```
